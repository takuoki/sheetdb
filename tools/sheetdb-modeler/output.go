package main

import (
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/takuoki/clmconv"
)

func (g *generator) output(m model, o option) {
	g.outputHeader(m)
	g.outputImport(m)
	g.outputConst(m, o)
	g.outputVar(m)
	g.outputCompileCheck(m, o)
	g.outputInit(m, o)
	g.outputLoad(m)
	g.outputGet(m)
	g.outputGetList(m)
	g.outputAdd(m, o)
	g.outputUpdate(m)
	g.outputDelete(m)
	g.outputValidate(m)
	g.outputParse(m)
	g.outputAsync(m, o)
}

func (g *generator) outputHeader(m model) {
	g.Printf("// Code generated by \"sheetdb-modeler\"; DO NOT EDIT.\n")
	g.Printf("// Create a Spreadsheet (sheet name: \"%s\") as data storage.\n", m.NameLowerPlural)
	g.Printf("// The spreadsheet header is as follows:\n")
	g.Printf("//   ")
	for _, f := range m.Fields {
		g.Printf("%s | ", strcase.ToSnake(f.Name))
	}
	g.Printf("updated_at | deleted_at\n")
	g.Printf("// Please copy and paste this header on the first line of the sheet.\n")
	g.Printf("\npackage %s\n\n", g.pkg.name)
}

func (g *generator) outputImport(m model) {

	var needStrconv bool
	for _, f := range m.Fields {
		switch f.TypNonPointer {
		case "bool", "int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64",
			"float32", "float64":
			needStrconv = true
			break
		}
	}

	g.Printf("import (\n")
	if needStrconv {
		g.Printf("\t\"strconv\"\n")
	}
	g.Printf("\t\"sync\"\n")
	g.Printf("\t\"time\"\n")
	g.Printf("\n")
	g.Printf("\t\"github.com/takuoki/gsheets\"\n")
	g.Printf("\t\"github.com/takuoki/sheetdb\"\n")
	g.Printf(")\n\n")
}

func (g *generator) outputConst(m model, o option) {
	g.Printf("const (\n")
	g.Printf("\t// Sheet definition\n")
	g.Printf("\t_%s_sheetName = \"%s\"\n", m.Name, m.NameLowerPlural)
	for i, f := range m.Fields {
		g.Printf("\t_%s_column_%s = %d // %s\n", m.Name, f.Name, i, clmconv.Itoa(i))
	}
	g.Printf("\t_%s_column_UpdatedAt = %d // %s\n", m.Name, len(m.Fields), clmconv.Itoa(len(m.Fields)))
	g.Printf("\t_%s_column_DeletedAt = %d // %s\n", m.Name, len(m.Fields)+1, clmconv.Itoa(len(m.Fields)+1))

	if m.Parent != nil || len(m.Children) > 0 {
		g.Printf("\t\n// Parent children relation for compile check\n")
		if m.Parent != nil {
			g.Printf("\t_%s_modelSetName_%s = 0\n", m.Name, o.ModelSetName)
		}
		if m.Parent != nil {
			g.Printf("\t_%s_parent_%s = 0\n", m.Name, m.Parent.Name)
		}
		for _, child := range m.DirectChildrenNames {
			g.Printf("\t_%s_child_%s = 0\n", m.Name, child)
		}
		g.Printf("\t_%s_numOfChildren = %d\n", m.Name, len(m.Children))
		g.Printf("\t_%s_numOfDirectChildren = %d\n", m.Name, len(m.DirectChildrenNames))
	}

	g.Printf(")\n\n")
}

func (g *generator) outputVar(m model) {
	g.Printf("var (\n")
	g.Printf("\t_%s_mutex = sync.RWMutex{}\n", m.Name)
	g.Printf("\t_%[1]s_cache = map[%[2]s]*%[1]s{} // map[%[3]s]*%[1]s\n", m.Name, strings.Join(m.PkTypes, "]map["), strings.Join(m.PkNameLowers, "]["))
	g.Printf("\t_%s_rowNoMap = map[%s]int{} // map[%[3]s]rowNo\n", m.Name, strings.Join(m.PkTypes, "]map["), strings.Join(m.PkNameLowers, "]["))
	g.Printf("\t_%s_maxRowNo = 0\n", m.Name)
	for _, f := range m.Fields {
		if f.Unique {
			g.Printf("\t_%[1]s_%[2]s_uniqueMap =map[string]*%[1]s{}\n", m.Name, f.Name)
		}
	}
	g.Printf(")\n\n")
}

func (g *generator) outputCompileCheck(m model, o option) {
	if m.Parent == nil && len(m.Children) == 0 {
		return
	}
	g.Printf("func _() {\n")
	if len(m.DirectChildrenNames) > 0 {
		g.Printf("\t// An \"undeclared name\" compiler error signifies that parent and child model set names are different.\n")
		g.Printf("\t// Make sure that all models in parent-child relationship exist in the same model set (spreadsheet) and try again.\n")
		for _, child := range m.DirectChildrenNames {
			g.Printf("\t_ = _%s_modelSetName_%s\n", child, o.ModelSetName)
		}
	}
	g.Printf("\t// An \"undeclared name\" compiler error signifies that parent-children option conflicts between models.\n")
	g.Printf("\t// Make sure that the parent-children options are correct for all relevant models and try again.\n")
	if m.Parent != nil {
		g.Printf("\t_ = _%[2]s_child_%[1]s\n", m.Name, m.Parent.Name)
	}
	for _, child := range m.DirectChildrenNames {
		g.Printf("\t_ = _%[2]s_parent_%[1]s\n", m.Name, child)
	}
	if len(m.Children) > 0 {
		g.Printf("\t// An \"invalid array index\" compiler error signifies that the children option is incorrect.\n")
		g.Printf("\t// Make sure that all child models are specified, including not only the direct child model\n")
		g.Printf("\t// but also the grandchild model, and try again.\n")
		g.Printf("\tvar x [1]struct{}\n")
		g.Printf("\t_ = x[_%[1]s_numOfChildren - _%[1]s_numOfDirectChildren", m.Name)
		for _, child := range m.DirectChildrenNames {
			g.Printf(" - _%s_numOfChildren", child)
		}
		g.Printf("\t]\n")
	}
	g.Printf("}\n\n")
}

func (g *generator) outputInit(m model, o option) {
	g.Printf("func init() {\n")
	g.Printf("\tsheetdb.RegisterModel(\"%[2]s\", \"%[1]s\", _%[1]s_sheetName, _%[1]s_load)\n", m.Name, o.ModelSetName)
	g.Printf("}\n\n")
}

func (g *generator) outputLoad(m model) {
	g.Printf("func _%s_load(data *gsheets.Sheet) error {\n\n", m.Name)

	g.Printf("\t_%s_mutex.Lock()\n", m.Name)
	g.Printf("\tdefer _%s_mutex.Unlock()\n\n", m.Name)

	g.Printf("\t_%[1]s_cache = map[%[2]s]*%[1]s{}\n", m.Name, strings.Join(m.PkTypes, "]map["))
	g.Printf("\t_%s_rowNoMap = map[%s]int{}\n", m.Name, strings.Join(m.PkTypes, "]map["))
	g.Printf("\t_%s_maxRowNo = 0\n\n", m.Name)

	g.Printf("\tfor i, r := range data.Rows() {\n")
	g.Printf("\t\tif i == 0 {\n")
	g.Printf("\t\t\tcontinue\n")
	g.Printf("\t\t}\n")
	g.Printf("\t\tif r.Value(_%s_column_DeletedAt) != \"\" {\n", m.Name)
	g.Printf("\t\t\t_%s_maxRowNo++\n", m.Name)
	g.Printf("\t\t\tcontinue\n")
	g.Printf("\t\t}\n")
	g.Printf("\t\tif r.Value(_%s_column_%s) == \"\" {\n", m.Name, m.Fields[0].Name)
	g.Printf("\t\t\tbreak\n")
	g.Printf("\t\t}\n\n")

	for _, f := range m.Fields {
		if f.Typ == "string" {
			g.Printf("\t\t%[3]s := r.Value(_%[1]s_column_%[2]s)\n", m.Name, f.Name, f.NameLower)
			if f.Unique {
				g.Printf("\t\tif err := _%[1]s_validate%[2]s(%[3]s, nil); err != nil {\n", m.Name, f.Name, f.NameLower)
			} else {
				g.Printf("\t\tif err := _%[1]s_validate%[2]s(%[3]s); err != nil {\n", m.Name, f.Name, f.NameLower)
			}
		} else {
			g.Printf("\t\t%[3]s, err := _%[1]s_parse%[2]s(r.Value(_%[1]s_column_%[2]s))\n", m.Name, f.Name, f.NameLower)
			g.Printf("\t\tif err != nil {\n")
		}
		g.Printf("\t\t\treturn err\n")
		g.Printf("\t\t}\n")
	}
	g.Printf("\n")

	g.Printf("\t\t%[2]s := %[1]s{\n", m.Name, m.NameLower)
	for _, f := range m.Fields {
		g.Printf("\t\t\t%s: %s,\n", f.Name, f.NameLower)
	}
	g.Printf("\t\t}\n\n")

	g.Printf("\t\t_%s_maxRowNo++\n", m.Name)
	g.outputParentMap(m)
	g.Printf("\t\t_%[1]s_cache[%[3]s] = &%[2]s\n", m.Name, m.NameLower, strings.Join(prefixes(m.PkNames, m.NameLower+"."), "]["))
	g.Printf("\t\t_%[1]s_rowNoMap[%[2]s] = _%[1]s_maxRowNo\n", m.Name, strings.Join(prefixes(m.PkNames, m.NameLower+"."), "]["))
	for _, f := range m.Fields {
		if f.Unique {
			g.Printf("\t\t_%[1]s_%[2]s_uniqueMap[%[3]s.%[2]s] = &%[3]s\n", m.Name, f.Name, m.NameLower)
		}
	}
	g.Printf("\t}\n\n")

	g.Printf("\treturn nil\n")
	g.Printf("}\n\n")
}

func (g *generator) outputParentMap(m model) {
	for i, f := range m.PkNames {
		if f == m.ThisKeyName {
			break
		}
		g.Printf("if _, ok := _%s_cache", m.Name)
		for j, f2 := range m.PkNames {
			if j > i {
				break
			}
			g.Printf("[%s.%s]", m.NameLower, f2)
		}
		g.Printf("; !ok {\n")
		// cache map
		g.Printf("\t	_%[1]s_cache", m.Name)
		for j, f2 := range m.PkNames {
			if j > i {
				break
			}
			g.Printf("[%s.%s]", m.NameLower, f2)
		}
		g.Printf(" = ")
		for j, f2 := range m.PkTypes {
			if j <= i {
				continue
			}
			g.Printf("map[%s]", f2)
		}
		g.Printf("*%[1]s{}\n", m.Name)
		// rowNo map
		g.Printf("\t	_%[1]s_rowNoMap", m.Name)
		for j, f2 := range m.PkNames {
			if j > i {
				break
			}
			g.Printf("[%s.%s]", m.NameLower, f2)
		}
		g.Printf(" = ")
		for j, f2 := range m.PkTypes {
			if j <= i {
				continue
			}
			g.Printf("map[%s]", f2)
		}
		g.Printf("int{}\n")

		g.Printf("}\n")
	}
}

func (g *generator) outputGet(m model) {

	g.Printf("// Get%[1]s returns a %[2]s by %[3]s.\n", m.Name, m.NameLower, m.ThisKeyName)
	if m.Parent == nil {
		g.Printf("// If it can not be found, this function returns sheetdb.NotFoundError.\n")
		g.Printf("func Get%[1]s(%[2]s) (*%[1]s, error) {\n", m.Name, join(m.PkNameLowers, m.PkTypes, " ", ", "))
	} else {
		g.Printf("// If it can not be found, this method returns sheetdb.NotFoundError.\n")
		g.Printf("func (m *%[2]s) Get%[1]s(%[3]s %[4]s) (*%[1]s, error) {\n", m.Name, m.Parent.Name, m.ThisKeyNameLower, m.ThisKeyType)
	}

	g.Printf("\t_%s_mutex.RLock()\n", m.Name)
	g.Printf("\tdefer _%s_mutex.RUnlock()\n", m.Name)

	if m.Parent == nil {
		g.Printf("\tif v, ok := _%s_cache[%s]; ok {\n", m.Name, m.ThisKeyNameLower)
	} else {
		g.Printf("\tif v, ok := _%s_cache[%s][%s]; ok {\n", m.Name, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["), m.ThisKeyNameLower)
	}

	g.Printf("\t\treturn v, nil\n")
	g.Printf("\t}\n")
	g.Printf("\treturn nil, &sheetdb.NotFoundError{Model: \"%s\"}\n", m.Name)
	g.Printf("}\n\n")

	if m.Parent != nil {
		g.Printf("// Get%[1]s returns a %[2]s by primary keys.\n", m.Name, m.NameLower)
		g.Printf("// If it can not be found, this function returns sheetdb.NotFoundError.\n")
		g.Printf("func Get%[1]s(%[2]s) (*%[1]s, error) {\n", m.Name, join(m.PkNameLowers, m.PkTypes, " ", ", "))
		g.outputGetParent(*m.Parent, true, 0)
		g.Printf("\treturn m.Get%s(%s)\n", m.Name, m.ThisKeyNameLower)
		g.Printf("}\n\n")
	}

	for _, f := range m.Fields {
		if f.Unique {
			g.Printf("// Get%[1]sBy%[3]s returns a %[2]s by %[3]s.\n", m.Name, m.NameLower, f.Name)
			g.Printf("// If it can not be found, this function returns sheetdb.NotFoundError.\n")
			g.Printf("func Get%[1]sBy%[2]s(%[3]s %[4]s) (*%[1]s, error) {\n", m.Name, f.Name, f.NameLower, f.Typ)
			g.Printf("\t_%s_mutex.RLock()\n", m.Name)
			g.Printf("\tdefer _%s_mutex.RUnlock()\n", m.Name)
			g.Printf("\tif v, ok := _%s_%s_uniqueMap[%s]; ok {\n", m.Name, f.Name, f.NameLower)
			g.Printf("\t\treturn v, nil\n")
			g.Printf("\t}\n")
			g.Printf("\treturn nil, &sheetdb.NotFoundError{Model: \"%s\"}\n", m.Name)
			g.Printf("}\n\n")
		}
	}
}

func (g *generator) outputGetParent(m model, returnNil bool, i int) {
	if m.Parent != nil {
		g.outputGetParent(*m.Parent, returnNil, i+1)
	}
	if i == 0 {
		g.Printf("\tm, err := Get%[1]s(%[2]s)\n", m.Name, strings.Join(m.PkNameLowers, ", "))
	} else {
		g.Printf("\tm%[3]d, err := Get%[1]s(%[2]s)\n", m.Name, strings.Join(m.PkNameLowers, ", "), i)
	}
	g.Printf("\tif err != nil {\n")
	if returnNil {
		g.Printf("\t\treturn nil, err\n")
	} else {
		g.Printf("\t\treturn err\n")
	}
	g.Printf("\t}\n")
}

func (g *generator) outputGetList(m model) {
	g.Printf("// %sQuery is used for selecting %s.\n", m.Name, m.NameLowerPlural)
	g.Printf("type %sQuery struct {\n", m.Name)
	g.Printf("\tfilter func(%[2]s *%[1]s) bool\n", m.Name, m.NameLower)
	g.Printf("\tsort   func(%[2]s []*%[1]s)\n", m.Name, m.NameLowerPlural)
	g.Printf("}\n\n")

	g.Printf("// %[1]sQueryOption is an option to change the behavior of %[1]sQuery.\n", m.Name)
	g.Printf("type %[1]sQueryOption func(query *%[1]sQuery) *%[1]sQuery\n\n", m.Name)

	g.Printf("// %[1]sFilter is an option to change the filtering behavior of %[1]sQuery.\n", m.Name)
	g.Printf("func %[1]sFilter(filterFunc func(%[2]s *%[1]s) bool) func(query *%[1]sQuery) *%[1]sQuery {\n", m.Name, m.NameLower)
	g.Printf("\treturn func(query *%[1]sQuery) *%[1]sQuery {\n", m.Name)
	g.Printf("\t\tif query != nil {\n")
	g.Printf("\t\t\tquery.filter = filterFunc\n")
	g.Printf("\t\t}\n")
	g.Printf("\t\treturn query\n")
	g.Printf("\t}\n")
	g.Printf("}\n\n")

	g.Printf("// %[1]sSort is an option to change the sorting behavior of %[1]sQuery.\n", m.Name)
	g.Printf("func %[1]sSort(sortFunc func(%[2]s []*%[1]s)) func(query *%[1]sQuery) *%[1]sQuery {\n", m.Name, m.NameLowerPlural)
	g.Printf("\treturn func(query *%[1]sQuery) *%[1]sQuery {\n", m.Name)
	g.Printf("\t\tif query != nil {\n")
	g.Printf("\t\t\tquery.sort = sortFunc\n")
	g.Printf("\t\t}\n")
	g.Printf("\t\treturn query\n")
	g.Printf("\t}\n")
	g.Printf("}\n\n")

	if m.Parent == nil {
		g.Printf("// Get%s returns all %s.\n", m.NamePlural, m.NameLowerPlural)
		g.Printf("// If any options are specified, the result according to the specified option is returned.\n")
		g.Printf("// If there are no %s to return, this function returns an nil array.\n", m.NameLower)
		g.Printf("func Get%[2]s(opts ...%[1]sQueryOption) ([]*%[1]s, error) {\n", m.Name, m.NamePlural)
	} else {
		g.Printf("// Get%s returns all %s that %s has.\n", m.NamePlural, m.NameLowerPlural, m.Parent.NameLower)
		g.Printf("// If any options are specified, the result according to the specified option is returned.\n")
		g.Printf("// If there are no %s to return, this method returns an nil array.\n", m.NameLower)
		g.Printf("func (m *%[3]s) Get%[2]s(opts ...%[1]sQueryOption) ([]*%[1]s, error) {\n", m.Name, m.NamePlural, m.Parent.Name)
	}

	g.Printf("\t%[2]sQuery := &%[1]sQuery{}\n", m.Name, m.NameLower)
	g.Printf("\tfor _, opt := range opts {\n")
	g.Printf("\t\t%[1]sQuery = opt(%[1]sQuery)\n", m.NameLower)
	g.Printf("\t}\n")
	g.Printf("\t_%s_mutex.RLock()\n", m.Name)
	g.Printf("\tdefer _%s_mutex.RUnlock()\n", m.Name)
	g.Printf("\tvar %[2]s []*%[1]s\n", m.Name, m.NameLowerPlural)
	g.Printf("\tif %sQuery.filter != nil {\n", m.NameLower)

	if m.Parent == nil {
		g.Printf("\t\tfor _, v := range _%s_cache {\n", m.Name)
	} else {
		g.Printf("\t\tfor _, v := range _%s_cache[%s] {\n", m.Name, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["))
	}

	g.Printf("\t\t\tif %sQuery.filter(v) {\n", m.NameLower)
	g.Printf("\t\t\t\t%[1]s = append(%[1]s, v)\n", m.NameLowerPlural)
	g.Printf("\t\t\t}\n")
	g.Printf("\t\t}\n")
	g.Printf("\t} else {\n")

	if m.Parent == nil {
		g.Printf("\t\tfor _, v := range _%s_cache {\n", m.Name)
	} else {
		g.Printf("\t\tfor _, v := range _%s_cache[%s] {\n", m.Name, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["))
	}

	g.Printf("\t\t\t%[1]s = append(%[1]s, v)\n", m.NameLowerPlural)
	g.Printf("\t\t}\n")
	g.Printf("\t}\n")
	g.Printf("\tif %sQuery.sort != nil {\n", m.NameLower)
	g.Printf("\t\t%sQuery.sort(%s)\n", m.NameLower, m.NameLowerPlural)
	g.Printf("\t}\n")
	g.Printf("\treturn %s, nil\n", m.NameLowerPlural)
	g.Printf("}\n\n")

	if m.Parent != nil {
		g.Printf("// Get%s returns all %s that %s has.\n", m.NamePlural, m.NameLowerPlural, m.Parent.NameLower)
		g.Printf("// If any options are specified, the result according to the specified option is returned.\n")
		g.Printf("// If there are no %s to return, this function returns an nil array.\n", m.NameLower)
		g.Printf("func Get%[2]s(%[3]s, opts ...%[1]sQueryOption) ([]*%[1]s, error) {\n", m.Name, m.NamePlural, join(m.Parent.PkNameLowers, m.Parent.PkTypes, " ", ", "))
		g.outputGetParent(*m.Parent, true, 0)
		g.Printf("\treturn m.Get%s(opts...)\n", m.NamePlural)
		g.Printf("}\n\n")
	}
}

func (g *generator) outputAdd(m model, o option) {

	if m.Parent == nil {
		g.Printf("// Add%s adds new %s.\n", m.Name, m.NameLower)
		if autoNumbering(m.ThisKeyName, m.ThisKeyType) {
			g.Printf("// %s is generated automatically.\n", m.ThisKeyName)
			g.Printf("// If any fields are invalid, this function returns error.\n")
			g.Printf("func Add%[1]s(%[2]s) (*%[1]s, error) {\n", m.Name, join(m.NonPkNameLowers, m.NonPkTypes, " ", ", "))
		} else {
			g.Printf("// If argument '%s' already exist, this function returns sheetdb.DuplicationError.\n", m.ThisKeyNameLower)
			g.Printf("// If any fields are invalid, this function returns error.\n")
			g.Printf("func Add%[1]s(%[2]s %[3]s, %[4]s) (*%[1]s, error) {\n", m.Name, m.ThisKeyNameLower, m.ThisKeyType, join(m.NonPkNameLowers, m.NonPkTypes, " ", ", "))
		}
	} else {
		g.Printf("// Add%s adds new %s to %s.\n", m.Name, m.NameLower, m.Parent.NameLower)
		if autoNumbering(m.ThisKeyName, m.ThisKeyType) {
			g.Printf("// %s is generated automatically.\n", m.ThisKeyName)
			g.Printf("// If any fields are invalid, this method returns error.\n")
			g.Printf("func (m *%[2]s) Add%[1]s(%[3]s) (*%[1]s, error) {\n", m.Name, m.Parent.Name, join(m.NonPkNameLowers, m.NonPkTypes, " ", ", "))
		} else {
			g.Printf("// If argument '%s' already exists in this %s, this method returns sheetdb.DuplicationError.\n", m.ThisKeyNameLower, m.Parent.NameLower)
			g.Printf("// If any fields are invalid, this method returns error.\n")
			g.Printf("func (m *%[4]s) Add%[1]s(%[2]s %[3]s, %[5]s) (*%[1]s, error) {\n", m.Name, m.ThisKeyNameLower, m.ThisKeyType, m.Parent.Name, join(m.NonPkNameLowers, m.NonPkTypes, " ", ", "))
		}
	}

	g.Printf("\t_%s_mutex.Lock()\n", m.Name)
	g.Printf("\tdefer _%s_mutex.Unlock()\n", m.Name)

	if !autoNumbering(m.ThisKeyName, m.ThisKeyType) {
		if m.Parent == nil {
			g.Printf("\tif _, ok := _%[1]s_cache[%[2]s]; ok {\n", m.Name, strings.Join(m.PkNameLowers, "]["))
		} else {
			g.Printf("\tif _, ok := _%[1]s_cache[%[2]s][%[3]s]; ok {\n", m.Name, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["), m.ThisKeyNameLower)
		}
		g.Printf("\t\treturn nil, &sheetdb.DuplicationError{FieldName: \"%s\"}\n", m.ThisKeyName)
		g.Printf("\t}\n")
	}

	for _, f := range m.Fields {
		if !f.IsPk && f.Typ == "string" {
			if f.Unique {
				g.Printf("\tif err := _%[1]s_validate%[2]s(%[3]s, nil); err != nil {\n", m.Name, f.Name, f.NameLower)
				g.Printf("\t\treturn nil, err\n")
				g.Printf("\t}\n")
			} else {
				g.Printf("\tif err := _%[1]s_validate%[2]s(%[3]s); err != nil {\n", m.Name, f.Name, f.NameLower)
				g.Printf("\t\treturn nil, err\n")
				g.Printf("\t}\n")
			}
		}
	}

	if m.Parent != nil && autoNumbering(m.ThisKeyName, m.ThisKeyType) {
		g.Printf("\tmaxID := 0\n")
		g.Printf("\tfor _, v := range _%[1]s_cache[%[2]s] {\n", m.Name, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["))
		g.Printf("\t\tif maxID < v.%s {\n", m.ThisKeyName)
		g.Printf("\t\t\tmaxID = v.%s\n", m.ThisKeyName)
		g.Printf("\t\t}\n")
		g.Printf("\t}\n")
	}

	g.Printf("\t%[2]s := &%[1]s{\n", m.Name, m.NameLower)

	for _, f := range m.Fields {
		if f.IsPk {
			if f.IsParentKey {
				g.Printf("\t\t%[1]s: m.%[1]s,\n", f.Name)
			} else if autoNumbering(f.Name, f.Typ) {
				if m.Parent == nil {
					g.Printf("\t\t%[2]s: _%[1]s_maxRowNo + %[3]d,\n", m.Name, f.Name, o.Initial)
				} else {
					g.Printf("\t\t%[1]s: maxID + %[2]d,\n", f.Name, o.Initial)
				}
			} else {
				g.Printf("\t\t%s: %s,\n", f.Name, f.NameLower)
			}
		} else {
			g.Printf("\t\t%s: %s,\n", f.Name, f.NameLower)
		}
	}

	g.Printf("\t}\n")
	g.Printf("\tif err := %[2]s._asyncAdd(_%[1]s_maxRowNo + 1); err != nil {\n", m.Name, m.NameLower)
	g.Printf("\t\treturn nil, err\n")
	g.Printf("\t}\n")
	g.Printf("\t_%s_maxRowNo++\n", m.Name)

	g.outputParentMap(m)

	g.Printf("\t_%[1]s_cache[%[3]s] = %[2]s\n", m.Name, m.NameLower, strings.Join(prefixes(m.PkNames, m.NameLower+"."), "]["))
	g.Printf("\t_%[1]s_rowNoMap[%[2]s] = _%[1]s_maxRowNo\n", m.Name, strings.Join(prefixes(m.PkNames, m.NameLower+"."), "]["))
	for _, f := range m.Fields {
		if f.Unique {
			g.Printf("\t_%[1]s_%[2]s_uniqueMap[%[3]s.%[2]s] = %[3]s\n", m.Name, f.Name, m.NameLower)
		}
	}
	g.Printf("\treturn %s, nil\n", m.NameLower)
	g.Printf("}\n\n")

	if m.Parent != nil {
		g.Printf("// Add%s adds new %s to %s.\n", m.Name, m.NameLower, m.Parent.NameLower)
		if autoNumbering(m.ThisKeyName, m.ThisKeyType) {
			g.Printf("// %s is generated automatically.\n", m.ThisKeyName)
			g.Printf("// If any fields are invalid, this function returns error.\n")
			g.Printf("func Add%[1]s(%[2]s, %[3]s) (*%[1]s, error) {\n", m.Name, join(m.Parent.PkNameLowers, m.Parent.PkTypes, " ", ", "), join(m.NonPkNameLowers, m.NonPkTypes, " ", ", "))
		} else {
			g.Printf("// If primary keys already exist, this function returns sheetdb.DuplicationError.\n")
			g.Printf("// If any fields are invalid, this function returns error.\n")
			g.Printf("func Add%[1]s(%[2]s) (*%[1]s, error) {\n", m.Name, join(m.FieldNameLowers, m.FieldTypes, " ", ", "))
		}
		g.outputGetParent(*m.Parent, true, 0)
		if autoNumbering(m.ThisKeyName, m.ThisKeyType) {
			g.Printf("\treturn m.Add%s(%s)\n", m.Name, strings.Join(m.NonPkNameLowers, ", "))
		} else {
			g.Printf("\treturn m.Add%s(%s, %s)\n", m.Name, m.ThisKeyNameLower, strings.Join(m.NonPkNameLowers, ", "))
		}
		g.Printf("}\n\n")
	}
}

func (g *generator) outputUpdate(m model) {

	if m.Parent == nil {
		g.Printf("// Update%s updates %s.\n", m.Name, m.NameLower)
		g.Printf("// If it can not be found, this function returns sheetdb.NotFoundError.\n")
		g.Printf("// If any fields are invalid, this function returns error.\n")
		g.Printf("func Update%[1]s(%[2]s) (*%[1]s, error) {\n", m.Name, join(m.FieldNameLowers, m.FieldTypes, " ", ", "))
	} else {
		g.Printf("// Update%s updates %s.\n", m.Name, m.NameLower)
		g.Printf("// If it can not be found, this method returns sheetdb.NotFoundError.\n")
		g.Printf("// If any fields are invalid, this method returns error.\n")
		g.Printf("func (m *%[2]s) Update%[1]s(%[3]s %[4]s, %[5]s) (*%[1]s, error) {\n", m.Name, m.Parent.Name, m.ThisKeyNameLower, m.ThisKeyType, join(m.NonPkNameLowers, m.NonPkTypes, " ", ", "))
	}

	g.Printf("\t_%s_mutex.Lock()\n", m.Name)
	g.Printf("\tdefer _%s_mutex.Unlock()\n", m.Name)

	if m.Parent == nil {
		g.Printf("\t%[2]s, ok := _%[1]s_cache[%[3]s]\n", m.Name, m.NameLower, m.ThisKeyNameLower)
	} else {
		g.Printf("\t%[2]s, ok := _%[1]s_cache[%[3]s][%[4]s]\n", m.Name, m.NameLower, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["), m.ThisKeyNameLower)
	}

	g.Printf("\tif !ok {\n")
	g.Printf("\t\treturn nil, &sheetdb.NotFoundError{Model: \"%s\"}\n", m.Name)
	g.Printf("\t}\n")

	for _, f := range m.Fields {
		if !f.IsPk && f.Typ == "string" {
			if f.Unique {
				g.Printf("\tif err := _%[1]s_validate%[3]s(%[4]s, &%[2]s.%[3]s); err != nil {\n", m.Name, m.NameLower, f.Name, f.NameLower)
			} else {
				g.Printf("\tif err := _%[1]s_validate%[2]s(%[3]s); err != nil {\n", m.Name, f.Name, f.NameLower)
			}
			g.Printf("\t\treturn nil, err\n")
			g.Printf("\t}\n")
		}
	}

	g.Printf("\t%[1]sCopy := *%[1]s\n", m.NameLower)

	for _, f := range m.Fields {
		if !f.IsPk {
			g.Printf("\t%sCopy.%s = %s\n", m.NameLower, f.Name, f.NameLower)
		}
	}

	g.Printf("\tif err := (&%sCopy)._asyncUpdate(); err != nil {\n", m.NameLower)
	g.Printf("\t\treturn nil, err\n")
	g.Printf("\t}\n")

	for _, f := range m.Fields {
		if f.Unique {
			g.Printf("\tif %[1]sCopy.%[2]s != %[1]s.%[2]s {\n", m.NameLower, f.Name)
			g.Printf("\t\tdelete(_%[1]s_%[3]s_uniqueMap, %[2]s.%[3]s)\n", m.Name, m.NameLower, f.Name)
			g.Printf("\t}\n")
		}
	}

	g.Printf("\t%[1]s = &%[1]sCopy\n", m.NameLower)
	for _, f := range m.Fields {
		if f.Unique {
			g.Printf("\t_%[1]s_%[3]s_uniqueMap[%[2]sCopy.%[3]s] = &%[2]sCopy\n", m.Name, m.NameLower, f.Name)
		}
	}
	g.Printf("\treturn %s, nil\n", m.NameLower)
	g.Printf("}\n\n")

	if m.Parent != nil {
		g.Printf("// Update%s updates %s.\n", m.Name, m.NameLower)
		g.Printf("// If it can not be found, this function returns sheetdb.NotFoundError.\n")
		g.Printf("// If any fields are invalid, this function returns error.\n")
		g.Printf("func Update%[1]s(%[2]s) (*%[1]s, error) {\n", m.Name, join(m.FieldNameLowers, m.FieldTypes, " ", ", "))
		g.outputGetParent(*m.Parent, true, 0)
		g.Printf("\treturn m.Update%s(%s, %s)\n", m.Name, m.ThisKeyNameLower, strings.Join(m.NonPkNameLowers, ", "))
		g.Printf("}\n\n")
	}
}

func (g *generator) outputDelete(m model) {

	if m.Parent == nil {
		if len(m.Children) == 0 {
			g.Printf("// Delete%[1]s deletes %[2]s.\n", m.Name, m.NameLower)
		} else if len(m.Children) == 1 {
			g.Printf("// Delete%[1]s deletes %[2]s and it's children %[3]s.\n", m.Name, m.NameLower, m.ChildrenNameLowers[0])
		} else {
			g.Printf("// Delete%[1]s deletes %[2]s and it's children %[3]s and %[4]s.\n", m.Name, m.NameLower, strings.Join(m.ChildrenNameLowers[:len(m.Children)-1], ", "), m.ChildrenNameLowers[len(m.Children)-1])
		}
		g.Printf("// If it can not be found, this function returns sheetdb.NotFoundError.\n")
		g.Printf("func Delete%[1]s(%[2]s %[3]s) error {\n", m.Name, m.ThisKeyNameLower, m.ThisKeyType)
	} else {
		if len(m.Children) == 0 {
			g.Printf("// Delete%[1]s deletes %[2]s from %[3]s.\n", m.Name, m.NameLower, m.Parent.NameLower)
		} else if len(m.Children) == 1 {
			g.Printf("// Delete%[1]s deletes %[2]s and it's children %[4]s from %[3]s.\n", m.Name, m.NameLower, m.Parent.NameLower, m.ChildrenNameLowers[0])
		} else {
			g.Printf("// Delete%[1]s deletes %[2]s and it's children %[4]s and %[5]s from %[3]s.\n", m.Name, m.NameLower, m.Parent.NameLower, strings.Join(m.ChildrenNameLowers[:len(m.Children)-1], ", "), m.ChildrenNameLowers[len(m.Children)-1])
		}
		g.Printf("// If it can not be found, this method returns sheetdb.NotFoundError.\n")
		g.Printf("func (m *%[2]s) Delete%[1]s(%[3]s %[4]s) error {\n", m.Name, m.Parent.Name, m.ThisKeyNameLower, m.ThisKeyType)
	}

	g.Printf("\t_%s_mutex.Lock()\n", m.Name)
	g.Printf("\tdefer _%s_mutex.Unlock()\n", m.Name)

	for _, child := range m.Children {
		g.Printf("\t_%s_mutex.Lock()\n", child.Name)
		g.Printf("\tdefer _%s_mutex.Unlock()\n", child.Name)
	}

	if m.Parent == nil {
		g.Printf("\t%[2]s, ok := _%[1]s_cache[%[3]s]\n", m.Name, m.NameLower, m.ThisKeyNameLower)
	} else {
		g.Printf("\t%[2]s, ok := _%[1]s_cache[%[3]s][%[4]s]\n", m.Name, m.NameLower, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["), m.ThisKeyNameLower)
	}

	g.Printf("\tif !ok {\n")
	g.Printf("\t\treturn &sheetdb.NotFoundError{Model: \"%s\"}\n", m.Name)
	g.Printf("\t}\n")

	for _, child := range m.Children {
		g.Printf("\tvar %[2]s []*%[1]s\n", child.Name, child.NameLowerPlural)
		if m.Parent == nil {
			g.Printf("\tfor _, v := range _%[1]s_cache[%[2]s] {\n", child.Name, m.ThisKeyNameLower)
		} else {
			g.Printf("\tfor _, v := range _%[1]s_cache[%[2]s][%[3]s] {\n", child.Name, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["), m.ThisKeyNameLower)
		}
		for i := 0; i < len(child.PkNames)-len(m.PkNames)-1; i++ {
			g.Printf("\tfor _, v := range v {\n")
		}
		g.Printf("\t\t%[1]s = append(%[1]s, v)\n", child.NameLowerPlural)
		for i := 0; i < len(child.PkNames)-len(m.PkNames)-1; i++ {
			g.Printf("\t}\n")
		}
		g.Printf("\t}\n")
	}

	g.Printf("\tif err := %s._asyncDelete(%s); err != nil {\n", m.NameLower, strings.Join(m.ChildrenNameLowerPlurals, ", "))
	g.Printf("\t\treturn err\n")
	g.Printf("\t}\n")

	for _, f := range m.Fields {
		if f.Unique {
			g.Printf("\tdelete(_%[1]s_%[3]s_uniqueMap, %[2]s.%[3]s)\n", m.Name, m.NameLower, f.Name)
		}
	}

	if m.Parent == nil {
		g.Printf("\tdelete(_%[1]s_cache, %[2]s)\n", m.Name, m.ThisKeyNameLower)
	} else {
		g.Printf("\tdelete(_%[1]s_cache[%[3]s], %[2]s)\n", m.Name, m.ThisKeyNameLower, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["))
	}

	for _, child := range m.Children {
		if m.Parent == nil {
			g.Printf("\tdelete(_%[1]s_cache, %[2]s)\n", child.Name, m.ThisKeyNameLower)
		} else {
			g.Printf("\tdelete(_%[1]s_cache[%[3]s], %[2]s)\n", child.Name, m.ThisKeyNameLower, strings.Join(prefixes(m.Parent.PkNames, "m."), "]["))
		}
	}

	g.Printf("\treturn nil\n")
	g.Printf("}\n\n")

	if m.Parent != nil {
		if len(m.Children) == 0 {
			g.Printf("// Delete%[1]s deletes %[2]s from %[3]s.\n", m.Name, m.NameLower, m.Parent.NameLower)
		} else if len(m.Children) == 1 {
			g.Printf("// Delete%[1]s deletes %[2]s and it's children %[4]s from %[3]s.\n", m.Name, m.NameLower, m.Parent.NameLower, m.ChildrenNameLowers[0])
		} else {
			g.Printf("// Delete%[1]s deletes %[2]s and it's children %[4]s and %[5]s from %[3]s.\n", m.Name, m.NameLower, m.Parent.NameLower, strings.Join(m.ChildrenNameLowers[:len(m.Children)-1], ", "), m.ChildrenNameLowers[len(m.Children)-1])
		}
		g.Printf("// If it can not be found, this function returns sheetdb.NotFoundError.\n")

		g.Printf("func Delete%[1]s(%[2]s) error {\n", m.Name, join(m.PkNameLowers, m.PkTypes, " ", ", "))
		g.outputGetParent(*m.Parent, false, 0)
		g.Printf("\treturn m.Delete%s(%s)\n", m.Name, m.ThisKeyNameLower)
		g.Printf("}\n\n")
	}
}

func (g *generator) outputValidate(m model) {
	pkNameAndTypes := []string{}
	pkEqualConditions := []string{}
	for _, f := range m.Fields {
		if f.IsPk {
			pkNameAndTypes = append(pkNameAndTypes, f.NameLower+" *"+f.Typ)
			pkEqualConditions = append(pkEqualConditions, "v."+f.Name+" == *"+f.NameLower)
		}
	}
	for _, f := range m.Fields {
		if f.Typ != "string" {
			continue
		}
		if f.Unique {
			g.Printf("func _%[1]s_validate%[2]s(%[3]s string, old%[2]s *string) error {\n", m.Name, f.Name, f.NameLower)
		} else {
			g.Printf("func _%[1]s_validate%[2]s(%[3]s string) error {\n", m.Name, f.Name, f.NameLower)
		}

		if !f.AllowEmpty {
			g.Printf("\tif %s == \"\" {\n", f.NameLower)
			g.Printf("\t\treturn &sheetdb.EmptyStringError{FieldName: \"%s\"}\n", f.Name)
			g.Printf("\t}\n")
		}

		if f.Unique {
			g.Printf("\tif old%[1]s == nil || *old%[1]s != %[2]s {\n", f.Name, f.NameLower)
			g.Printf("\t\tif _, ok := _%[1]s_%[2]s_uniqueMap[%[3]s]; ok {\n", m.Name, f.Name, f.NameLower)
			g.Printf("\t\t\treturn &sheetdb.DuplicationError{FieldName: \"%s\"}\n", f.Name)
			g.Printf("\t\t}\n")
			g.Printf("\t}\n")
		}

		g.Printf("\treturn nil\n")
		g.Printf("}\n\n")
	}
}

func (g *generator) outputParse(m model) {

	for _, f := range m.Fields {
		if f.Typ == "string" {
			continue
		}
		g.Printf("func _%s_parse%s(%s string) (%s, error) {\n", m.Name, f.Name, f.NameLower, f.Typ)

		if f.IsPointer {
			g.Printf("\tvar val %s\n", f.Typ)
			g.Printf("\tif %s != \"\" {\n", f.NameLower)
		}

		switch f.Typ {
		case "bool", "*bool":
			g.Printf("\tv, err := strconv.ParseBool(%s)\n", f.NameLower)
		case "int", "*int":
			g.Printf("\tv, err := strconv.Atoi(%s)\n", f.NameLower)
		case "int8", "*int8":
			g.Printf("\tv, err := strconv.ParseInt(%s, 10, 8)\n", f.NameLower)
		case "int16", "*int16":
			g.Printf("\tv, err := strconv.ParseInt(%s, 10, 16)\n", f.NameLower)
		case "int32", "*int32":
			g.Printf("\tv, err := strconv.ParseInt(%s, 10, 32)\n", f.NameLower)
		case "int64", "*int64":
			g.Printf("\tv, err := strconv.ParseInt(%s, 10, 64)\n", f.NameLower)
		case "uint", "*uint":
			g.Printf("\tv, err := strconv.ParseUint(%s, 10, 64)\n", f.NameLower)
		case "uint8", "*uint8":
			g.Printf("\tv, err := strconv.ParseUint(%s, 10, 8)\n", f.NameLower)
		case "uint16", "*uint16":
			g.Printf("\tv, err := strconv.ParseUint(%s, 10, 16)\n", f.NameLower)
		case "uint32", "*uint32":
			g.Printf("\tv, err := strconv.ParseUint(%s, 10, 32)\n", f.NameLower)
		case "uint64", "*uint64":
			g.Printf("\tv, err := strconv.ParseUint(%s, 10, 64)\n", f.NameLower)
		case "float32", "*float32":
			g.Printf("\tv, err := strconv.ParseFloat(%s, 32)\n", f.NameLower)
		case "float64", "*float64":
			g.Printf("\tv, err := strconv.ParseFloat(%s, 64)\n", f.NameLower)
		default:
			if f.Package == "" {
				g.Printf("\tv, err := New%s(%s)\n", f.TypNonPointer, f.NameLower)
			} else {
				g.Printf("\tv, err := %s.New%s(%s)\n", f.Package, f.TypRaw, f.NameLower)
			}
		}

		g.Printf("\tif err != nil {\n")
		g.Printf("\t\treturn %[2]s, &sheetdb.InvalidValueError{FieldName: \"%[1]s\", Err: err}\n", f.Name, nilValue(f.Typ))
		g.Printf("\t}\n")

		if f.IsPointer {
			switch t := f.TypNonPointer; t {
			case "int8", "int16", "int32",
				"uint", "uint8", "uint16", "uint32",
				"float32", "float64":
				g.Printf("\t\tv2 := %s(v)\n", t)
				g.Printf("\t\tval = &v2\n")
			default:
				g.Printf("\t\tval = &v\n")
			}
			g.Printf("\t}\n")
			g.Printf("\treturn val, nil\n")
		} else {
			switch t := f.Typ; t {
			case "int8", "int16", "int32",
				"uint", "uint8", "uint16", "uint32",
				"float32", "float64":
				g.Printf("\treturn %s(v), nil\n", t)
			default:
				g.Printf("\treturn v, nil\n")
			}
		}

		g.Printf("}\n\n")
	}
}

func (g *generator) outputAsync(m model, o option) {

	g.Printf("func (m *%s) _asyncAdd(rowNo int) error {\n", m.Name)
	g.Printf("\tdata := []gsheets.UpdateValue{\n")
	g.Printf("\t\t{\n")
	g.Printf("\t\t\tSheetName: _%s_sheetName,\n", m.Name)
	g.Printf("\t\t\tRowNo:     rowNo,\n")
	g.Printf("\t\t\tValues: []interface{}{\n")

	for _, f := range m.Fields {
		switch f.TypNonPointer {
		case "string", "bool",
			"int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64",
			"float32", "float64":
			g.Printf("\t\t\t\tm.%s,\n", f.Name)
		default:
			g.Printf("\t\t\t\tm.%s.String(),\n", f.Name)
		}
	}

	g.Printf("\t\t\t\ttime.Now(),\n")
	g.Printf("\t\t\t\t\"\",\n")
	g.Printf("\t\t\t},\n")
	g.Printf("\t\t},\n")
	g.Printf("\t}\n")
	g.Printf("\treturn %s.AsyncUpdate(data)\n", o.ClientName)
	g.Printf("}\n\n")

	g.Printf("func (m *%s) _asyncUpdate() error {\n", m.Name)
	g.Printf("\tdata := []gsheets.UpdateValue{\n")
	g.Printf("\t\t{\n")
	g.Printf("\t\t\tSheetName: _%s_sheetName,\n", m.Name)
	g.Printf("\t\t\tRowNo:     _%[1]s_rowNoMap[%[2]s],\n", m.Name, strings.Join(prefixes(m.PkNames, "m."), "]["))
	g.Printf("\t\t\tValues: []interface{}{\n")

	for _, f := range m.Fields {
		switch f.TypNonPointer {
		case "string", "bool",
			"int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64",
			"float32", "float64":
			g.Printf("\t\t\t\tm.%s,\n", f.Name)
		default:
			g.Printf("\t\t\t\tm.%s.String(),\n", f.Name)
		}
	}

	g.Printf("\t\t\t\ttime.Now(),\n")
	g.Printf("\t\t\t\t\"\",\n")
	g.Printf("\t\t\t},\n")
	g.Printf("\t\t},\n")
	g.Printf("\t}\n")
	g.Printf("\treturn %s.AsyncUpdate(data)\n", o.ClientName)
	g.Printf("}\n\n")

	g.Printf("func (m *%[1]s) _asyncDelete(%[2]s) error {\n", m.Name, join(m.ChildrenNameLowerPlurals, m.ChildrenNames, " []*", ", "))
	g.Printf("\tnow := time.Now()\n")
	g.Printf("\tdata := []gsheets.UpdateValue{\n")
	g.Printf("\t\t{\n")
	g.Printf("\t\t\tSheetName: _%s_sheetName,\n", m.Name)
	g.Printf("\t\t\tRowNo:     _%[1]s_rowNoMap[%[2]s],\n", m.Name, strings.Join(prefixes(m.PkNames, "m."), "]["))
	g.Printf("\t\t\tValues: []interface{}{\n")

	for _, f := range m.Fields {
		switch f.TypNonPointer {
		case "string", "bool",
			"int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64",
			"float32", "float64":
			g.Printf("\t\t\t\tm.%s,\n", f.Name)
		default:
			g.Printf("\t\t\t\tm.%s.String(),\n", f.Name)
		}
	}

	g.Printf("\t\t\t\tnow,\n")
	g.Printf("\t\t\t\tnow,\n")
	g.Printf("\t\t\t},\n")
	g.Printf("\t\t},\n")
	g.Printf("\t}\n")

	for i, child := range m.Children {
		g.Printf("\tfor _, v := range %s {\n", child.NameLowerPlural)
		g.Printf("\t\tdata = append(data, gsheets.UpdateValue{\n")
		g.Printf("\t\t\tSheetName: _%s_sheetName,\n", child.Name)
		g.Printf("\t\t\tRowNo:     _%s_rowNoMap[%s],\n", child.Name, strings.Join(prefixes(m.Children[i].PkNames, "v."), "]["))
		g.Printf("\t\t\tValues: []interface{}{\n")

		for _, f := range child.Fields {
			switch f.TypNonPointer {
			case "string", "bool",
				"int", "int8", "int16", "int32", "int64",
				"uint", "uint8", "uint16", "uint32", "uint64",
				"float32", "float64":
				g.Printf("\t\t\t\tv.%s,\n", f.Name)
			default:
				g.Printf("\t\t\t\tv.%s.String(),\n", f.Name)
			}
		}

		g.Printf("\t\t\t\tnow,\n")
		g.Printf("\t\t\t\tnow,\n")
		g.Printf("\t\t\t},\n")
		g.Printf("\t\t})\n")
		g.Printf("\t}\n")
	}

	g.Printf("\treturn %s.AsyncUpdate(data)\n", o.ClientName)
	g.Printf("}\n")
}

// Helper

func autoNumbering(pkName, pkType string) bool {
	if pkType == "int" && pkName[len(pkName)-2:] == "ID" {
		return true
	}
	return false
}

func nilValue(t string) string {
	if t == "" {
		return ""
	}
	if t[0] == '*' {
		return "nil"
	}
	switch t {
	case "string":
		return `""`
	case "bool":
		return "false"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "0"
	case "sheetdb.Date", "sheetdb.Datetime":
		return t + "{}"
	}
	// user definition type
	return "v"
}

func prefixes(strs []string, prefix string) []string {
	r := []string{}
	for _, str := range strs {
		r = append(r, prefix+str)
	}
	return r
}

func join(s1, s2 []string, delimiter, separater string) string {
	if len(s1) != len(s2) {
		panic("join functions arguments are invalid: the length of s1 and s2 should be same")
	}
	r := []string{}
	for i := 0; i < len(s1); i++ {
		r = append(r, s1[i]+delimiter+s2[i])
	}
	return strings.Join(r, separater)
}
