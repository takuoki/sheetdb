// Code generated by "sheetdb-modeler"; DO NOT EDIT.
// Create a Spreadsheet (sheet name: "foos") as data storage.
// The spreadsheet header is as follows:
//   user_id | foo_id | value | note | updated_at | deleted_at
// Please copy and paste this header on the first line of the sheet.

package sample

import (
	"strconv"
	"sync"
	"time"

	"github.com/takuoki/gsheets"
	"github.com/takuoki/sheetdb"
)

const (
	// Sheet definition
	_Foo_sheetName        = "foos"
	_Foo_column_UserID    = 0 // A
	_Foo_column_FooID     = 1 // B
	_Foo_column_Value     = 2 // C
	_Foo_column_Note      = 3 // D
	_Foo_column_UpdatedAt = 4 // E
	_Foo_column_DeletedAt = 5 // F

	// Parent children relation for compile check
	_Foo_modelSetName_default = 0
	_Foo_parent_User          = 0
	_Foo_child_FooChild       = 0
	_Foo_numOfChildren        = 1
	_Foo_numOfDirectChildren  = 1
)

var (
	_Foo_mutex    = sync.RWMutex{}
	_Foo_cache    = map[int]map[int]*Foo{} // map[userID][fooID]*Foo
	_Foo_rowNoMap = map[int]map[int]int{}  // map[userID][fooID]rowNo
	_Foo_maxRowNo = 0
)

func _() {
	// An "undeclared name" compiler error signifies that parent and child model set names are different.
	// Make sure that all models in parent-child relationship exist in the same model set (spreadsheet) and try again.
	_ = _FooChild_modelSetName_default
	// An "undeclared name" compiler error signifies that parent-children option conflicts between models.
	// Make sure that the parent-children options are correct for all relevant models and try again.
	_ = _User_child_Foo
	_ = _FooChild_parent_Foo
	// An "invalid array index" compiler error signifies that the children option is incorrect.
	// Make sure that all child models are specified, including not only the direct child model
	// but also the grandchild model, and try again.
	var x [1]struct{}
	_ = x[_Foo_numOfChildren-_Foo_numOfDirectChildren-_FooChild_numOfChildren]
}

func init() {
	sheetdb.RegisterModel("default", "Foo", _Foo_sheetName, _Foo_load)
}

func _Foo_load(data *gsheets.Sheet) error {

	_Foo_mutex.Lock()
	defer _Foo_mutex.Unlock()

	_Foo_cache = map[int]map[int]*Foo{}
	_Foo_rowNoMap = map[int]map[int]int{}
	_Foo_maxRowNo = 0

	for i, r := range data.Rows() {
		if i == 0 {
			continue
		}
		if r.Value(_Foo_column_DeletedAt) != "" {
			_Foo_maxRowNo++
			continue
		}
		if r.Value(_Foo_column_UserID) == "" {
			break
		}

		userID, err := _Foo_parseUserID(r.Value(_Foo_column_UserID))
		if err != nil {
			return err
		}
		fooID, err := _Foo_parseFooID(r.Value(_Foo_column_FooID))
		if err != nil {
			return err
		}
		value, err := _Foo_parseValue(r.Value(_Foo_column_Value))
		if err != nil {
			return err
		}
		note := r.Value(_Foo_column_Note)
		if err := _Foo_validateNote(note); err != nil {
			return err
		}

		if _, ok := _Foo_cache[userID][fooID]; ok {
			return &sheetdb.DuplicationError{FieldName: "FooID"}
		}

		foo := Foo{
			UserID: userID,
			FooID:  fooID,
			Value:  value,
			Note:   note,
		}

		_Foo_maxRowNo++
		if _, ok := _Foo_cache[foo.UserID]; !ok {
			_Foo_cache[foo.UserID] = map[int]*Foo{}
			_Foo_rowNoMap[foo.UserID] = map[int]int{}
		}
		_Foo_cache[foo.UserID][foo.FooID] = &foo
		_Foo_rowNoMap[foo.UserID][foo.FooID] = _Foo_maxRowNo
	}

	return nil
}

// GetFoo returns a foo by FooID.
// If it can not be found, this method returns *sheetdb.NotFoundError.
func (m *User) GetFoo(fooID int) (*Foo, error) {
	_Foo_mutex.RLock()
	defer _Foo_mutex.RUnlock()
	if v, ok := _Foo_cache[m.UserID][fooID]; ok {
		return v, nil
	}
	return nil, &sheetdb.NotFoundError{Model: "Foo"}
}

// GetFoo returns a foo by primary keys.
// If it can not be found, this function returns *sheetdb.NotFoundError.
func GetFoo(userID int, fooID int) (*Foo, error) {
	m, err := GetUser(userID)
	if err != nil {
		return nil, err
	}
	return m.GetFoo(fooID)
}

// FooQuery is used for selecting foos.
type FooQuery struct {
	filter func(foo *Foo) bool
	sort   func(foos []*Foo)
}

// FooQueryOption is an option to change the behavior of FooQuery.
type FooQueryOption func(query *FooQuery) *FooQuery

// FooFilter is an option to change the filtering behavior of FooQuery.
func FooFilter(filterFunc func(foo *Foo) bool) func(query *FooQuery) *FooQuery {
	return func(query *FooQuery) *FooQuery {
		if query != nil {
			query.filter = filterFunc
		}
		return query
	}
}

// FooSort is an option to change the sorting behavior of FooQuery.
func FooSort(sortFunc func(foos []*Foo)) func(query *FooQuery) *FooQuery {
	return func(query *FooQuery) *FooQuery {
		if query != nil {
			query.sort = sortFunc
		}
		return query
	}
}

// GetFoos returns all foos that user has.
// If any options are specified, the result according to the specified option is returned.
// If there are no foo to return, this method returns an nil array.
// If the sort option is not specified, the order of foos is random.
func (m *User) GetFoos(opts ...FooQueryOption) ([]*Foo, error) {
	query := &FooQuery{}
	for _, opt := range opts {
		query = opt(query)
	}
	_Foo_mutex.RLock()
	defer _Foo_mutex.RUnlock()
	var foos []*Foo
	if query.filter != nil {
		for _, v := range _Foo_cache[m.UserID] {
			if query.filter(v) {
				foos = append(foos, v)
			}
		}
	} else {
		for _, v := range _Foo_cache[m.UserID] {
			foos = append(foos, v)
		}
	}
	if query.sort != nil {
		query.sort(foos)
	}
	return foos, nil
}

// GetFoos returns all foos that user has.
// If any options are specified, the result according to the specified option is returned.
// If there are no foo to return, this function returns an nil array.
// If the sort option is not specified, the order of foos is random.
func GetFoos(userID int, opts ...FooQueryOption) ([]*Foo, error) {
	m, err := GetUser(userID)
	if err != nil {
		return nil, err
	}
	return m.GetFoos(opts...)
}

// AddFoo adds new foo to user.
// FooID is generated automatically.
// If any fields are invalid, this method returns error.
func (m *User) AddFoo(value float32, note string) (*Foo, error) {
	_Foo_mutex.Lock()
	defer _Foo_mutex.Unlock()
	if err := _Foo_validateNote(note); err != nil {
		return nil, err
	}
	maxID := 0
	for _, v := range _Foo_cache[m.UserID] {
		if maxID < v.FooID {
			maxID = v.FooID
		}
	}
	foo := &Foo{
		UserID: m.UserID,
		FooID:  maxID + 1,
		Value:  value,
		Note:   note,
	}
	if err := foo._asyncAdd(_Foo_maxRowNo + 1); err != nil {
		return nil, err
	}
	_Foo_maxRowNo++
	if _, ok := _Foo_cache[foo.UserID]; !ok {
		_Foo_cache[foo.UserID] = map[int]*Foo{}
		_Foo_rowNoMap[foo.UserID] = map[int]int{}
	}
	_Foo_cache[foo.UserID][foo.FooID] = foo
	_Foo_rowNoMap[foo.UserID][foo.FooID] = _Foo_maxRowNo
	return foo, nil
}

// AddFoo adds new foo to user.
// FooID is generated automatically.
// If any fields are invalid, this function returns error.
func AddFoo(userID int, value float32, note string) (*Foo, error) {
	m, err := GetUser(userID)
	if err != nil {
		return nil, err
	}
	return m.AddFoo(value, note)
}

// UpdateFoo updates foo.
// If it can not be found, this method returns *sheetdb.NotFoundError.
// If any fields are invalid, this method returns error.
func (m *User) UpdateFoo(fooID int, value float32, note string) (*Foo, error) {
	_Foo_mutex.Lock()
	defer _Foo_mutex.Unlock()
	foo, ok := _Foo_cache[m.UserID][fooID]
	if !ok {
		return nil, &sheetdb.NotFoundError{Model: "Foo"}
	}
	if err := _Foo_validateNote(note); err != nil {
		return nil, err
	}
	fooCopy := *foo
	fooCopy.Value = value
	fooCopy.Note = note
	if err := (&fooCopy)._asyncUpdate(); err != nil {
		return nil, err
	}
	*foo = fooCopy
	return foo, nil
}

// UpdateFoo updates foo.
// If it can not be found, this function returns *sheetdb.NotFoundError.
// If any fields are invalid, this function returns error.
func UpdateFoo(userID int, fooID int, value float32, note string) (*Foo, error) {
	m, err := GetUser(userID)
	if err != nil {
		return nil, err
	}
	return m.UpdateFoo(fooID, value, note)
}

// DeleteFoo deletes foo and it's children fooChild from user.
// If it can not be found, this method returns *sheetdb.NotFoundError.
func (m *User) DeleteFoo(fooID int) error {
	_Foo_mutex.Lock()
	defer _Foo_mutex.Unlock()
	_FooChild_mutex.Lock()
	defer _FooChild_mutex.Unlock()
	foo, ok := _Foo_cache[m.UserID][fooID]
	if !ok {
		return &sheetdb.NotFoundError{Model: "Foo"}
	}
	var fooChildren []*FooChild
	for _, v := range _FooChild_cache[m.UserID][fooID] {
		fooChildren = append(fooChildren, v)
	}
	if err := foo._asyncDelete(fooChildren); err != nil {
		return err
	}
	delete(_Foo_cache[m.UserID], fooID)
	delete(_FooChild_cache[m.UserID], fooID)
	delete(_FooChild_Value_uniqueMap[m.UserID], fooID)
	return nil
}

// DeleteFoo deletes foo and it's children fooChild from user.
// If it can not be found, this function returns *sheetdb.NotFoundError.
func DeleteFoo(userID int, fooID int) error {
	m, err := GetUser(userID)
	if err != nil {
		return err
	}
	return m.DeleteFoo(fooID)
}

func _Foo_validateNote(note string) error {
	return nil
}

func _Foo_parseUserID(userID string) (int, error) {
	v, err := strconv.Atoi(userID)
	if err != nil {
		return 0, &sheetdb.InvalidValueError{FieldName: "UserID", Err: err}
	}
	return v, nil
}

func _Foo_parseFooID(fooID string) (int, error) {
	v, err := strconv.Atoi(fooID)
	if err != nil {
		return 0, &sheetdb.InvalidValueError{FieldName: "FooID", Err: err}
	}
	return v, nil
}

func _Foo_parseValue(value string) (float32, error) {
	v, err := strconv.ParseFloat(value, 32)
	if err != nil {
		return 0, &sheetdb.InvalidValueError{FieldName: "Value", Err: err}
	}
	return float32(v), nil
}

func (m *Foo) _asyncAdd(rowNo int) error {
	data := []gsheets.UpdateValue{
		{
			SheetName: _Foo_sheetName,
			RowNo:     rowNo,
			Values: []interface{}{
				m.UserID,
				m.FooID,
				m.Value,
				m.Note,
				time.Now().UTC(),
				"",
			},
		},
	}
	return dbClient.AsyncUpdate(data)
}

func (m *Foo) _asyncUpdate() error {
	data := []gsheets.UpdateValue{
		{
			SheetName: _Foo_sheetName,
			RowNo:     _Foo_rowNoMap[m.UserID][m.FooID],
			Values: []interface{}{
				m.UserID,
				m.FooID,
				m.Value,
				m.Note,
				time.Now().UTC(),
				"",
			},
		},
	}
	return dbClient.AsyncUpdate(data)
}

func (m *Foo) _asyncDelete(fooChildren []*FooChild) error {
	now := time.Now().UTC()
	data := []gsheets.UpdateValue{
		{
			SheetName: _Foo_sheetName,
			RowNo:     _Foo_rowNoMap[m.UserID][m.FooID],
			Values: []interface{}{
				m.UserID,
				m.FooID,
				m.Value,
				m.Note,
				now,
				now,
			},
		},
	}
	for _, v := range fooChildren {
		data = append(data, gsheets.UpdateValue{
			SheetName: _FooChild_sheetName,
			RowNo:     _FooChild_rowNoMap[v.UserID][v.FooID][v.ChildID],
			Values: []interface{}{
				v.UserID,
				v.FooID,
				v.ChildID,
				v.Value,
				now,
				now,
			},
		})
	}
	return dbClient.AsyncUpdate(data)
}
