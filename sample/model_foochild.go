// Code generated by "sheetdb-modeler"; DO NOT EDIT.
// Create a Spreadsheet (sheet name: "fooChildren") as data storage.
// The spreadsheet header is as follows:
//   user_id | foo_id | child_id | value | updated_at | deleted_at
// Please copy and paste this header on the first line of the sheet.

package sample

import (
	"strconv"
	"sync"
	"time"

	"github.com/takuoki/gsheets"
	"github.com/takuoki/sheetdb"
)

const (
	// Sheet definition
	_FooChild_sheetName        = "fooChildren"
	_FooChild_column_UserID    = 0 // A
	_FooChild_column_FooID     = 1 // B
	_FooChild_column_ChildID   = 2 // C
	_FooChild_column_Value     = 3 // D
	_FooChild_column_UpdatedAt = 4 // E
	_FooChild_column_DeletedAt = 5 // F

	// Parent children relation for compile check
	_FooChild_modelSetName_default = 0
	_FooChild_parent_Foo           = 0
	_FooChild_numOfChildren        = 0
	_FooChild_numOfDirectChildren  = 0
)

var (
	_FooChild_mutex           = sync.RWMutex{}
	_FooChild_cache           = map[int]map[int]map[int]*FooChild{} // map[userID][fooID][childID]*FooChild
	_FooChild_rowNoMap        = map[int]map[int]map[int]int{}       // map[userID][fooID][childID]rowNo
	_FooChild_maxRowNo        = 0
	_FooChild_Value_uniqueMap = map[string]*FooChild{}
)

func _() {
	// An "undeclared name" compiler error signifies that parent-children option conflicts between models.
	// Make sure that the parent-children options are correct for all relevant models and try again.
	_ = _Foo_child_FooChild
}

func init() {
	sheetdb.RegisterModel("default", "FooChild", _FooChild_sheetName, _FooChild_load)
}

func _FooChild_load(data *gsheets.Sheet) error {

	_FooChild_mutex.Lock()
	defer _FooChild_mutex.Unlock()

	_FooChild_cache = map[int]map[int]map[int]*FooChild{}
	_FooChild_rowNoMap = map[int]map[int]map[int]int{}
	_FooChild_maxRowNo = 0
	_FooChild_Value_uniqueMap = map[string]*FooChild{}

	for i, r := range data.Rows() {
		if i == 0 {
			continue
		}
		if r.Value(_FooChild_column_DeletedAt) != "" {
			_FooChild_maxRowNo++
			continue
		}
		if r.Value(_FooChild_column_UserID) == "" {
			break
		}

		userID, err := _FooChild_parseUserID(r.Value(_FooChild_column_UserID))
		if err != nil {
			return err
		}
		fooID, err := _FooChild_parseFooID(r.Value(_FooChild_column_FooID))
		if err != nil {
			return err
		}
		childID, err := _FooChild_parseChildID(r.Value(_FooChild_column_ChildID))
		if err != nil {
			return err
		}
		value := r.Value(_FooChild_column_Value)
		if err := _FooChild_validateValue(value, nil); err != nil {
			return err
		}

		fooChild := FooChild{
			UserID:  userID,
			FooID:   fooID,
			ChildID: childID,
			Value:   value,
		}

		_FooChild_maxRowNo++
		if _, ok := _FooChild_cache[fooChild.UserID]; !ok {
			_FooChild_cache[fooChild.UserID] = map[int]map[int]*FooChild{}
			_FooChild_rowNoMap[fooChild.UserID] = map[int]map[int]int{}
		}
		if _, ok := _FooChild_cache[fooChild.UserID][fooChild.FooID]; !ok {
			_FooChild_cache[fooChild.UserID][fooChild.FooID] = map[int]*FooChild{}
			_FooChild_rowNoMap[fooChild.UserID][fooChild.FooID] = map[int]int{}
		}
		_FooChild_cache[fooChild.UserID][fooChild.FooID][fooChild.ChildID] = &fooChild
		_FooChild_rowNoMap[fooChild.UserID][fooChild.FooID][fooChild.ChildID] = _FooChild_maxRowNo
		_FooChild_Value_uniqueMap[fooChild.Value] = &fooChild
	}

	return nil
}

// GetFooChild returns a fooChild by ChildID.
// If it can not be found, this method returns *sheetdb.NotFoundError.
func (m *Foo) GetFooChild(childID int) (*FooChild, error) {
	_FooChild_mutex.RLock()
	defer _FooChild_mutex.RUnlock()
	if v, ok := _FooChild_cache[m.UserID][m.FooID][childID]; ok {
		return v, nil
	}
	return nil, &sheetdb.NotFoundError{Model: "FooChild"}
}

// GetFooChild returns a fooChild by primary keys.
// If it can not be found, this function returns *sheetdb.NotFoundError.
func GetFooChild(userID int, fooID int, childID int) (*FooChild, error) {
	m, err := GetFoo(userID, fooID)
	if err != nil {
		return nil, err
	}
	return m.GetFooChild(childID)
}

// GetFooChildByValue returns a fooChild by Value.
// If it can not be found, this function returns *sheetdb.NotFoundError.
func GetFooChildByValue(value string) (*FooChild, error) {
	_FooChild_mutex.RLock()
	defer _FooChild_mutex.RUnlock()
	if v, ok := _FooChild_Value_uniqueMap[value]; ok {
		return v, nil
	}
	return nil, &sheetdb.NotFoundError{Model: "FooChild"}
}

// FooChildQuery is used for selecting fooChildren.
type FooChildQuery struct {
	filter func(fooChild *FooChild) bool
	sort   func(fooChildren []*FooChild)
}

// FooChildQueryOption is an option to change the behavior of FooChildQuery.
type FooChildQueryOption func(query *FooChildQuery) *FooChildQuery

// FooChildFilter is an option to change the filtering behavior of FooChildQuery.
func FooChildFilter(filterFunc func(fooChild *FooChild) bool) func(query *FooChildQuery) *FooChildQuery {
	return func(query *FooChildQuery) *FooChildQuery {
		if query != nil {
			query.filter = filterFunc
		}
		return query
	}
}

// FooChildSort is an option to change the sorting behavior of FooChildQuery.
func FooChildSort(sortFunc func(fooChildren []*FooChild)) func(query *FooChildQuery) *FooChildQuery {
	return func(query *FooChildQuery) *FooChildQuery {
		if query != nil {
			query.sort = sortFunc
		}
		return query
	}
}

// GetFooChildren returns all fooChildren that foo has.
// If any options are specified, the result according to the specified option is returned.
// If there are no fooChild to return, this method returns an nil array.
// If the sort option is not specified, the order of fooChildren is random.
func (m *Foo) GetFooChildren(opts ...FooChildQueryOption) ([]*FooChild, error) {
	fooChildQuery := &FooChildQuery{}
	for _, opt := range opts {
		fooChildQuery = opt(fooChildQuery)
	}
	_FooChild_mutex.RLock()
	defer _FooChild_mutex.RUnlock()
	var fooChildren []*FooChild
	if fooChildQuery.filter != nil {
		for _, v := range _FooChild_cache[m.UserID][m.FooID] {
			if fooChildQuery.filter(v) {
				fooChildren = append(fooChildren, v)
			}
		}
	} else {
		for _, v := range _FooChild_cache[m.UserID][m.FooID] {
			fooChildren = append(fooChildren, v)
		}
	}
	if fooChildQuery.sort != nil {
		fooChildQuery.sort(fooChildren)
	}
	return fooChildren, nil
}

// GetFooChildren returns all fooChildren that foo has.
// If any options are specified, the result according to the specified option is returned.
// If there are no fooChild to return, this function returns an nil array.
// If the sort option is not specified, the order of fooChildren is random.
func GetFooChildren(userID int, fooID int, opts ...FooChildQueryOption) ([]*FooChild, error) {
	m, err := GetFoo(userID, fooID)
	if err != nil {
		return nil, err
	}
	return m.GetFooChildren(opts...)
}

// AddFooChild adds new fooChild to foo.
// ChildID is generated automatically.
// If any fields are invalid, this method returns error.
func (m *Foo) AddFooChild(value string) (*FooChild, error) {
	_FooChild_mutex.Lock()
	defer _FooChild_mutex.Unlock()
	if err := _FooChild_validateValue(value, nil); err != nil {
		return nil, err
	}
	maxID := 0
	for _, v := range _FooChild_cache[m.UserID][m.FooID] {
		if maxID < v.ChildID {
			maxID = v.ChildID
		}
	}
	fooChild := &FooChild{
		UserID:  m.UserID,
		FooID:   m.FooID,
		ChildID: maxID + 1,
		Value:   value,
	}
	if err := fooChild._asyncAdd(_FooChild_maxRowNo + 1); err != nil {
		return nil, err
	}
	_FooChild_maxRowNo++
	if _, ok := _FooChild_cache[fooChild.UserID]; !ok {
		_FooChild_cache[fooChild.UserID] = map[int]map[int]*FooChild{}
		_FooChild_rowNoMap[fooChild.UserID] = map[int]map[int]int{}
	}
	if _, ok := _FooChild_cache[fooChild.UserID][fooChild.FooID]; !ok {
		_FooChild_cache[fooChild.UserID][fooChild.FooID] = map[int]*FooChild{}
		_FooChild_rowNoMap[fooChild.UserID][fooChild.FooID] = map[int]int{}
	}
	_FooChild_cache[fooChild.UserID][fooChild.FooID][fooChild.ChildID] = fooChild
	_FooChild_rowNoMap[fooChild.UserID][fooChild.FooID][fooChild.ChildID] = _FooChild_maxRowNo
	_FooChild_Value_uniqueMap[fooChild.Value] = fooChild
	return fooChild, nil
}

// AddFooChild adds new fooChild to foo.
// ChildID is generated automatically.
// If any fields are invalid, this function returns error.
func AddFooChild(userID int, fooID int, value string) (*FooChild, error) {
	m, err := GetFoo(userID, fooID)
	if err != nil {
		return nil, err
	}
	return m.AddFooChild(value)
}

// UpdateFooChild updates fooChild.
// If it can not be found, this method returns *sheetdb.NotFoundError.
// If any fields are invalid, this method returns error.
func (m *Foo) UpdateFooChild(childID int, value string) (*FooChild, error) {
	_FooChild_mutex.Lock()
	defer _FooChild_mutex.Unlock()
	fooChild, ok := _FooChild_cache[m.UserID][m.FooID][childID]
	if !ok {
		return nil, &sheetdb.NotFoundError{Model: "FooChild"}
	}
	if err := _FooChild_validateValue(value, &fooChild.Value); err != nil {
		return nil, err
	}
	fooChildCopy := *fooChild
	fooChildCopy.Value = value
	if err := (&fooChildCopy)._asyncUpdate(); err != nil {
		return nil, err
	}
	if fooChildCopy.Value != fooChild.Value {
		delete(_FooChild_Value_uniqueMap, fooChild.Value)
	}
	*fooChild = fooChildCopy
	_FooChild_Value_uniqueMap[fooChildCopy.Value] = &fooChildCopy
	return fooChild, nil
}

// UpdateFooChild updates fooChild.
// If it can not be found, this function returns *sheetdb.NotFoundError.
// If any fields are invalid, this function returns error.
func UpdateFooChild(userID int, fooID int, childID int, value string) (*FooChild, error) {
	m, err := GetFoo(userID, fooID)
	if err != nil {
		return nil, err
	}
	return m.UpdateFooChild(childID, value)
}

// DeleteFooChild deletes fooChild from foo.
// If it can not be found, this method returns *sheetdb.NotFoundError.
func (m *Foo) DeleteFooChild(childID int) error {
	_FooChild_mutex.Lock()
	defer _FooChild_mutex.Unlock()
	fooChild, ok := _FooChild_cache[m.UserID][m.FooID][childID]
	if !ok {
		return &sheetdb.NotFoundError{Model: "FooChild"}
	}
	if err := fooChild._asyncDelete(); err != nil {
		return err
	}
	delete(_FooChild_cache[m.UserID][m.FooID], childID)
	delete(_FooChild_Value_uniqueMap, fooChild.Value)
	return nil
}

// DeleteFooChild deletes fooChild from foo.
// If it can not be found, this function returns *sheetdb.NotFoundError.
func DeleteFooChild(userID int, fooID int, childID int) error {
	m, err := GetFoo(userID, fooID)
	if err != nil {
		return err
	}
	return m.DeleteFooChild(childID)
}

func _FooChild_validateValue(value string, oldValue *string) error {
	if value == "" {
		return &sheetdb.EmptyStringError{FieldName: "Value"}
	}
	if oldValue == nil || *oldValue != value {
		if _, ok := _FooChild_Value_uniqueMap[value]; ok {
			return &sheetdb.DuplicationError{FieldName: "Value"}
		}
	}
	return nil
}

func _FooChild_parseUserID(userID string) (int, error) {
	v, err := strconv.Atoi(userID)
	if err != nil {
		return 0, &sheetdb.InvalidValueError{FieldName: "UserID", Err: err}
	}
	return v, nil
}

func _FooChild_parseFooID(fooID string) (int, error) {
	v, err := strconv.Atoi(fooID)
	if err != nil {
		return 0, &sheetdb.InvalidValueError{FieldName: "FooID", Err: err}
	}
	return v, nil
}

func _FooChild_parseChildID(childID string) (int, error) {
	v, err := strconv.Atoi(childID)
	if err != nil {
		return 0, &sheetdb.InvalidValueError{FieldName: "ChildID", Err: err}
	}
	return v, nil
}

func (m *FooChild) _asyncAdd(rowNo int) error {
	data := []gsheets.UpdateValue{
		{
			SheetName: _FooChild_sheetName,
			RowNo:     rowNo,
			Values: []interface{}{
				m.UserID,
				m.FooID,
				m.ChildID,
				m.Value,
				time.Now(),
				"",
			},
		},
	}
	return dbClient.AsyncUpdate(data)
}

func (m *FooChild) _asyncUpdate() error {
	data := []gsheets.UpdateValue{
		{
			SheetName: _FooChild_sheetName,
			RowNo:     _FooChild_rowNoMap[m.UserID][m.FooID][m.ChildID],
			Values: []interface{}{
				m.UserID,
				m.FooID,
				m.ChildID,
				m.Value,
				time.Now(),
				"",
			},
		},
	}
	return dbClient.AsyncUpdate(data)
}

func (m *FooChild) _asyncDelete() error {
	now := time.Now()
	data := []gsheets.UpdateValue{
		{
			SheetName: _FooChild_sheetName,
			RowNo:     _FooChild_rowNoMap[m.UserID][m.FooID][m.ChildID],
			Values: []interface{}{
				m.UserID,
				m.FooID,
				m.ChildID,
				m.Value,
				now,
				now,
			},
		},
	}
	return dbClient.AsyncUpdate(data)
}
